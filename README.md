# Projeto Final de Arquitetura

- **Marciana Cosa Pereira**

### Desenvolvimento do Projeto

Este projeto tem como objetivo a implementa√ß√£o de um sistema acad√™mico inspirado no funcionamento do iFood, utilizando-se de conceitos s√≥lidos de Arquitetura de Software e, principalmente, padr√µes de projeto. A proposta visa simular um sistema de pedidos que envolva diferentes tipos de estabelecimentos (restaurante, mercado e farm√°cia), com foco na flexibilidade, manuten√ß√£o e escalabilidade da aplica√ß√£o.
Durante o desenvolvimento, foram aplicados seis padr√µes de projeto que estruturam tanto a l√≥gica de neg√≥cio quanto o comportamento interno do sistema. Abaixo, detalhamos a aplica√ß√£o de cada padr√£o escolhido.

---

### 1. Singleton Pattern üè¢
### 2. Factory Method Pattern üè≠
### 3. State Pattern üîÑ
### 4. Observer Pattern üëÅÔ∏è
### 5. Strategy Pattern üí≥
### 6. Command Pattern ‚ö°


## Fluxo de Funcionamento do Sistema

1. **Inicializa√ß√£o do Sistema**
   
    O sistema √© iniciado utilizando o padr√£o Singleton, por meio da classe SistemaIFood, que garante uma √∫nica inst√¢ncia respons√°vel por gerenciar todos os pedidos.
    Essa inst√¢ncia centraliza as opera√ß√µes e fornece acesso √†s funcionalidades principais do sistema.

2. **Cria√ß√£o do Pedido**
   
   O cliente escolhe o tipo de estabelecimento (restaurante, mercado ou farm√°cia).
   O sistema aciona a Factory Method, selecionando a factory correspondente (PedidoRestauranteFactory, PedidoMercadoFactory ou PedidoFarmaciaFactory) para criar o objeto do tipo Pedido.
   O pedido √© ent√£o vinculado ao cliente, que ser√° seu observador (Observer).

3. **Defini√ß√£o do Pagamento**
   
   Antes da confirma√ß√£o, o cliente seleciona o m√©todo de pagamento desejado (cart√£o, Pix ou dinheiro).
   O sistema utiliza o padr√£o Strategy para aplicar dinamicamente a estrat√©gia de pagamento escolhida, mantendo a l√≥gica de processamento desacoplada da l√≥gica do pedido.

4. **Agendamento do Pedido**
   
  O pedido, ao ser confirmado, √© agendado com data e hora, e seu estado interno muda de SemEstado para Agendado por meio do padr√£o State.
  Essa transi√ß√£o √© controlada e v√°lida apenas se o pedido ainda n√£o tiver sido finalizado.

5. **Notifica√ß√µes ao Cliente**
   
  A cada mudan√ßa de estado (agendado, entregue, cancelado), o cliente √© notificado automaticamente, gra√ßas ao uso do padr√£o Observer.
  Isso garante uma comunica√ß√£o desacoplada e em tempo real entre o sistema e o usu√°rio final.

6. **Execu√ß√£o de A√ß√µes sobre o Pedido**
    
 A entrega ou o cancelamento de um pedido s√£o tratados como comandos encapsulados (por exemplo, EntregarPedidoCommand, CancelarPedidoCommand).
 O Command Pattern permite executar essas a√ß√µes de forma controlada, al√©m de registrar o hist√≥rico de comandos para eventual revers√£o.

7. **Finaliza√ß√£o**
    
 O pedido termina em um dos estados finais: Entregue ou Cancelado.
Ap√≥s a finaliza√ß√£o, nenhuma nova transi√ß√£o de estado √© permitida.
O sistema armazena o hist√≥rico de comandos executados, possibilitando an√°lise posterior das opera√ß√µes realizadas.


